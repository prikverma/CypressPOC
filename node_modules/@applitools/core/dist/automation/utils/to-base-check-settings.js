"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toBaseCheckSettings = exports.extractMobileElementsIntoCheckSettings = exports.hasCodedRegions = void 0;
const utils = __importStar(require("@applitools/utils"));
const regionTypes = ['ignore', 'layout', 'strict', 'content', 'floating', 'accessibility'];
function hasCodedRegions(settings) {
    for (const regionType of regionTypes) {
        if (settings[`${regionType}Regions`])
            return true;
    }
    return false;
}
exports.hasCodedRegions = hasCodedRegions;
async function extractMobileElementsIntoCheckSettings({ settings, driver, logger, }) {
    logger = logger.extend({ tags: [`extract-mobile-elements-${utils.general.shortid()}`] });
    if (settings.region) {
        logger.log('extract element form region', settings.region);
        const region = await driver.element(settings.region).catch(error => logger.log(error));
        if (!region) {
            throw new Error('region not found');
        }
        settings.region = await (region === null || region === void 0 ? void 0 : region.getAttribute('name'));
    }
    if (settings.scrollRootElement) {
        logger.log('extract element form scrollRootElement', settings.scrollRootElement);
        const scrollRootElement = await driver.element(settings.scrollRootElement).catch(error => logger.log(error));
        if (!scrollRootElement) {
            throw new Error('scrollRootElement not found');
        }
        settings.scrollRootElement = await scrollRootElement.getAttribute('name');
    }
    const codedRegionsAsElement = await regionTypes.reduce(async (promise, regionType) => {
        var _a, _b;
        const obj = await promise;
        if (!settings[`${regionType}Regions`])
            return obj;
        obj[`${regionType}Regions`] = (await Promise.all((_b = (_a = settings[`${regionType}Regions`]) === null || _a === void 0 ? void 0 : _a.flatMap(async (reference) => {
            logger.log('extract element form region', reference);
            const { region } = utils.types.has(reference, 'region') ? reference : { region: reference };
            const handleRegion = new Set();
            const elements = await driver.elements(region).catch(error => logger.log(error));
            if (!elements)
                return []; // elements not found
            return elements === null || elements === void 0 ? void 0 : elements.reduce(async (promise, element) => {
                const arr = await promise;
                const name = await element.getAttribute('name');
                if (handleRegion.has(name))
                    return arr;
                handleRegion.add(name);
                return arr.concat({
                    region: {
                        name,
                        reference: region,
                    },
                });
            }, Promise.resolve([]));
        })) !== null && _b !== void 0 ? _b : [])).flat();
        return obj;
    }, Promise.resolve({}));
    return {
        ...settings,
        ...codedRegionsAsElement,
    };
}
exports.extractMobileElementsIntoCheckSettings = extractMobileElementsIntoCheckSettings;
function toBaseCheckSettings({ settings }) {
    const calculate = regionTypes.flatMap(regionType => {
        var _a;
        return ((_a = settings[`${regionType}Regions`]) !== null && _a !== void 0 ? _a : []).reduce((regions, reference) => {
            const { region } = utils.types.has(reference, 'region') ? reference : { region: reference };
            return !isRegion(region) ? regions.concat(region) : regions;
        }, []);
    });
    const target = !isRegion(settings.region) ? settings.region : undefined;
    const scrolling = settings.scrollRootElement;
    return { elementReferences: { target, scrolling, calculate }, getBaseCheckSettings };
    function getBaseCheckSettings({ calculatedRegions, preserveTransformation, }) {
        const transformedSettings = { ...settings };
        if (!preserveTransformation) {
            delete transformedSettings.region;
            delete transformedSettings.normalization;
        }
        else if (target) {
            delete transformedSettings.region;
        }
        regionTypes.forEach(regionType => {
            var _a;
            if (!transformedSettings[`${regionType}Regions`])
                return;
            transformedSettings[`${regionType}Regions`] = (_a = transformedSettings[`${regionType}Regions`]) === null || _a === void 0 ? void 0 : _a.flatMap(reference => {
                const { region, ...options } = utils.types.has(reference, 'region') ? reference : { region: reference };
                if (isRegion(region))
                    return reference;
                const { selector, regions } = calculatedRegions.shift();
                return regions.map(region => ({
                    region,
                    regionId: utils.types.isString(selector) ? selector : selector === null || selector === void 0 ? void 0 : selector.selector,
                    ...options,
                }));
            });
        });
        return transformedSettings;
    }
    function isRegion(region) {
        return utils.types.has(region, ['x', 'y', 'width', 'height']);
    }
}
exports.toBaseCheckSettings = toBaseCheckSettings;
