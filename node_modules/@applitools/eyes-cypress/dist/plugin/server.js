"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const webSocket_1 = __importDefault(require("./webSocket"));
const core_1 = require("@applitools/core");
const handleTestResults_1 = __importDefault(require("./handleTestResults"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const https_1 = require("https");
const ws_1 = require("ws");
const util_1 = require("util");
const extractEnvironment_1 = require("../plugin/extractEnvironment");
function makeStartServer({ logger, eyesConfig }) {
    return async function startServer(options) {
        const key = fs_1.default.readFileSync(path_1.default.resolve(__dirname, '../../src/pem/server.key'));
        const cert = fs_1.default.readFileSync(path_1.default.resolve(__dirname, '../../src/pem/server.cert'));
        const https = new https_1.Server({
            key,
            cert,
        });
        await (0, util_1.promisify)(https.listen.bind(https))();
        const port = https.address().port;
        const wss = new ws_1.Server({ server: https, path: '/eyes', maxPayload: 254 * 1024 * 1024 });
        wss.on('close', () => {
            https.close();
            closeUniversalServer();
        });
        const environment = (0, extractEnvironment_1.extractEnvironment)(options);
        const { port: universalPort, close: closeUniversalServer } = await (0, core_1.makeCoreServer)({
            idleTimeout: 0,
            printStdout: true,
            singleton: false,
            portResolutionMode: 'random',
            environment,
            debug: eyesConfig.universalDebug,
        });
        const managers = [];
        let socketWithUniversal;
        wss.on('connection', socketWithClient => {
            socketWithUniversal = (0, webSocket_1.default)(`ws://localhost:${universalPort}/eyes`);
            socketWithUniversal.setPassthroughListener((message) => {
                logger.log('<== ', message.toString().slice(0, 1000));
                const { name, payload } = JSON.parse(message);
                if (name === 'Core.makeManager') {
                    managers.push({ manager: payload.result, socketWithUniversal });
                }
                socketWithClient.send(message.toString());
            });
            socketWithClient.on('message', (message) => {
                const msg = JSON.parse(message);
                logger.log('==> ', message.toString().slice(0, 1000));
                if (msg.name === 'Test.printTestResults') {
                    try {
                        if (msg.payload.resultConfig.tapDirPath && msg.payload.resultConfig.shouldCreateTapFile) {
                            handleTestResults_1.default.handleBatchResultsFile(msg.payload.testResults, {
                                tapFileName: msg.payload.resultConfig.tapFileName,
                                tapDirPath: msg.payload.resultConfig.tapDirPath,
                            });
                        }
                        handleTestResults_1.default.printTestResults({
                            testResults: msg.payload.testResults,
                            resultConfig: msg.payload.resultConfig,
                        });
                        socketWithClient.send(JSON.stringify({
                            name: 'Test.printTestResults',
                            key: msg.key,
                            payload: { result: 'success' },
                        }));
                    }
                    catch (ex) {
                        socketWithClient.send(JSON.stringify({
                            name: 'Test.printTestResults',
                            key: msg.key,
                            payload: { result: ex.message.toString() },
                        }));
                    }
                }
                else {
                    socketWithUniversal.send(message);
                }
            });
        });
        return {
            server: wss,
            port,
            closeManagers,
            closeBatches,
            closeUniversalServer,
        };
        function closeManagers() {
            return Promise.all(managers.map(({ manager, socketWithUniversal }) => socketWithUniversal.request('EyesManager.getResults', {
                manager,
                settings: { throwErr: false, removeDuplicateTests: eyesConfig.eyesRemoveDuplicateTests },
            })));
        }
        function closeBatches(settings) {
            if (socketWithUniversal)
                return socketWithUniversal.request('Core.closeBatch', { settings }).catch((err) => {
                    logger.log('@@@', err);
                });
        }
    };
}
exports.default = makeStartServer;
